#!/usr/bin/perl
use strict;
use warnings;

open(DEF, 'he3.def') or die 'Can not open he3.def: $!';
open(OUT_C,   '> he3.h')    or die 'Can not open he3.h: $!';
open(OUT_F77, '> he3.fh')   or die 'Can not open he3.fh: $!';
open(OUT_F90, '> he3.f90h') or die 'Can not open he3.f90h: $!';
open(OUT_OCT, '> octave/he3.tab') or die 'Can not open octave/he3.tab: $!';
open(OUT_OCF,'> he3funcs.h') or die 'Can not open octave_f/he3functs.tab: $!';

my $head = "This file is generated by $0 script. Don't modify it!";
print OUT_C   "/* $head */\n";
print OUT_F77 "! $head\n";
print OUT_F90 "! $head\n";
print OUT_OCF "/* $head */\n";

print OUT_C   "#ifndef HE3_H\n#define HE3_H\n";

# This is the only difference between F77 and F90 header files.
# We need this to avoid possible linker problems
# See http://gcc.gnu.org/onlinedocs/gcc-3.4.6/g77/Block-Data-and-Libraries.html#Block-Data-and-Libraries
print OUT_F90 "external he3_const_block\n";

# NaN definition for fortran
my $fnan =qq{
!NaN parameter. -fno-range-check should be used in compilation!
      real*8 NaN
      parameter (NaN = 0D0/0D0)
};
print OUT_F77 $fnan;
print OUT_F90 $fnan;

my $fcblk="! Common blocks for all constants\n";
my $tab_c="";
my $tab_f="";
foreach (<DEF>){
  ## hidden comments
  next if /^##/;
  ## spaces
  if (/^\s*$/){
    print OUT_C;
    print OUT_F77;
    print OUT_F90;
    next;
  }
  chomp;
  ## comments
  if (/^\s*#(.*)$/){
    print OUT_C "/*$1 */\n";
    print OUT_F77 "!$1\n";
    print OUT_F90 "!$1\n";
    next;
  }
  ## constants
  if (/^\s*([^\s\(\)]+)(\s*)(#\s*(.*))?$/){
    my ($name, $sp, $comm) = ($1, $2, $4);
    # C
    my $ccomm = defined($comm)? "$sp/* $comm */": "";
    print OUT_C   "extern double ${name}_;$ccomm\n";
    # F
    my $fcomm = defined($comm)? "$sp! $comm": "";
    my $ffunc = "      real*8 $name$fcomm\n";
    $fcblk  .= sprintf("        common %15s $name\n", "/$name/");
    print OUT_F77 $ffunc;
    print OUT_F90 $ffunc;
    # Octave table
    my $ocomm = $comm || '';
    print OUT_OCT "$name 0 $sp$name -- $ocomm\n";
    print OUT_OCF "CONST(${name}_, 0, \"$ocomm\")\n";
    # TAB
    my $tcomm = defined($comm)? "$comm": "";
    $tcomm =~ s/\"/\\\"/g;
    $tab_c .= sprintf "{%-22s %-36s 0, \"\", %s},\n",
      "\"$name\",", "(const void*)&${name}_,", "\"$tcomm\"";

    open(OCT_F, "> m/$name.m") or die "can't open octave_f/$name.m: $!";
      print OCT_F "function v=$name() v=he3lib(\"$name\"); end";
    close(OCT_F);
    next;
  }
  ## functions
  if (/^\s*([^\s\(\)]+)\(([^)]+)\)(\s*)(#\s*(.*))?$/){
    my ($name, $args, $sp, $comm) = ($1, $2, $3, $5);
    # C
    my @args = split(/\s*,\s*/, $args);
    my $cargs = 'double *' . join(', double *', @args);
    my $ccomm = defined($comm)? "$sp/* $comm */": "";
    print OUT_C "double ${name}_($cargs);$ccomm\n";
    # F
    my $fcomm = defined($comm)? "$sp! $comm": "";
    my $ffunc = "      real*8 $name$fcomm\n";
    print OUT_F77 $ffunc;
    print OUT_F90 $ffunc;
    # Octave table
    my $ocomm = $comm || '';
    my $nargs = $#args+1;
    print OUT_OCT "$name $nargs $sp$name($args) -- $ocomm\n";
    print OUT_OCF "FUNC(${name}_, $nargs, \"$ocomm\")\n";
    # TAB
    my $tcomm = defined($comm)? "$comm": "";
    $tcomm =~ s/\"/\\\"/g;
    my $targs = $args;
    $targs =~ s/[\s,]+/ /g;
    $tab_f .= sprintf "{%-22s %-36s %d, %-20s %s},\n", 
      "\"$name\",", "(const void*)&${name}_,", $#args+1, "\"$targs\",", "\"$tcomm\"";

    open(OCT_F, "> m/$name.m") or die "can't open octave_f/$name.m: $!";
      print OCT_F "function v=$name(varargin) v=he3lib(\"$name\", varargin{:}); end";
    close(OCT_F);
    next;
  }
}

print OUT_C   "#endif\n";

# Write common blocks
print OUT_F77 $fcblk;
print OUT_F90 $fcblk;

close DEF;
close OUT_C;
close OUT_F77;
close OUT_F90;
close OUT_OCT;

# write TAB file for a command line interface
open(OUT_TAB, '> he3tab.h') or die 'Can not open he3tab.h: $!';
print OUT_TAB qq|/* $head */
#include <stdio.h>
#include <stdlib.h>
#include "he3.h"
struct tab_t {
  const char * name;
  const void * func;
  const int    narg;
  const char * args;
  const char * comm;
};
struct tab_t const_tab[] = {
${tab_c}{NULL,NULL,0,NULL,NULL}};
struct tab_t func_tab[] = {
${tab_f}{NULL,NULL,0,NULL,NULL}};
|;
close OUT_TAB;
